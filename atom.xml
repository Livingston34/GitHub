<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Livingston</title>
  
  <subtitle>“你没车没房没卡,拿什么和我谈恋爱？”“......我有高达......”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Livingston34/"/>
  <updated>2018-03-06T09:21:31.555Z</updated>
  <id>https://github.com/Livingston34/</id>
  
  <author>
    <name>杨霁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>koa2实现数据爬虫</title>
    <link href="https://github.com/Livingston34/2018/03/06/koa2%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB/"/>
    <id>https://github.com/Livingston34/2018/03/06/koa2实现数据爬虫/</id>
    <published>2018-03-06T08:31:39.619Z</published>
    <updated>2018-03-06T09:21:31.555Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Koa2制作爬虫的全过程，包括项目建立，使用superagent获取源数据、使用cheerio解析，Json数据返回。<br><a id="more"></a></p><h1 id="项目建立"><a href="#项目建立" class="headerlink" title="项目建立"></a>项目建立</h1><h2 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h2><blockquote><p>npm install -g koa-generator</p></blockquote><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><blockquote><p>koa2 koaCrawler </p></blockquote><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><blockquote><p>cd koaCrawler<br>npm install<br>npm start<br>浏览器访问<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></p></blockquote><h1 id="superagent应用"><a href="#superagent应用" class="headerlink" title="superagent应用"></a>superagent应用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>npm install superagent</p></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const superagent = require(&apos;superagent&apos;);</span><br><span class="line">const getData = async () =&gt; &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">var items = [];</span><br><span class="line">superagent</span><br><span class="line">.get(&apos;http://ny.gold600.com/&apos;)</span><br><span class="line">.end(function(err, res) &#123;</span><br><span class="line">if (err) reject(err);</span><br><span class="line">resolve(res.text);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="cheerio应用"><a href="#cheerio应用" class="headerlink" title="cheerio应用"></a>cheerio应用</h1><blockquote><p>具体使用Google一下</p></blockquote><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><blockquote><p>npm install cheerio</p></blockquote><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const $ = cheerio.load(res.text);</span><br><span class="line">$(&apos;.oilTable tbody tr:nth-child(odd)&apos;).each(function(i, elem) &#123;</span><br><span class="line">    let _this = $(elem);</span><br><span class="line">let s = &#123;</span><br><span class="line">city: _this.find(&apos;a&apos;).text().replace(/\s/g,&apos;&apos;),</span><br><span class="line">price90: $(_this.find(&apos;td&apos;)[1]).text().replace(/\s/g,&apos;&apos;),</span><br><span class="line">price93: $(_this.find(&apos;td&apos;)[2]).text().replace(/\s/g,&apos;&apos;),</span><br><span class="line">price97: $(_this.find(&apos;td&apos;)[3]).text().replace(/\s/g,&apos;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">items.push(s);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><blockquote><p><a href="https://github.com/Livingston34/koaCrawler">https://github.com/Livingston34/koaCrawler</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Koa2制作爬虫的全过程，包括项目建立，使用superagent获取源数据、使用cheerio解析，Json数据返回。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ubuntu上安装MySQL</title>
    <link href="https://github.com/Livingston34/2018/03/06/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85MySQL/"/>
    <id>https://github.com/Livingston34/2018/03/06/Ubuntu上安装MySQL/</id>
    <published>2018-03-06T02:16:49.162Z</published>
    <updated>2018-03-06T02:41:10.839Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>MySQL是流行的数据库系统，下面记录了在Ubuntu 16.04上安装MySQL步骤。</p><a id="more"></a><h1 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h1><blockquote><p>su apt update</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>apt install mysql-server mysql-client</p></blockquote><p>在安装过程中需要你输入MySQL管理员用户（root）密码。</p><h1 id="初始化安全脚本"><a href="#初始化安全脚本" class="headerlink" title="初始化安全脚本"></a>初始化安全脚本</h1><blockquote><p>mysql_secure_installation</p></blockquote><h1 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h1><blockquote><p>mysql -u root -p<br>输入root密码</p></blockquote><ul><li>-u 表示选择登陆的用户名</li><li>-p 表示登陆的用户密码</li></ul><h1 id="查看端口号"><a href="#查看端口号" class="headerlink" title="查看端口号"></a>查看端口号</h1><blockquote><p>show global variables like ‘port’;</p></blockquote><h1 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h1><blockquote><p>service mysqld start </p></blockquote><h1 id="停止mysql"><a href="#停止mysql" class="headerlink" title="停止mysql"></a>停止mysql</h1><blockquote><p>service mysqld stop </p></blockquote><h1 id="重启mysql"><a href="#重启mysql" class="headerlink" title="重启mysql"></a>重启mysql</h1><blockquote><p>service mysqld restart </p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="2003错误"><a href="#2003错误" class="headerlink" title="2003错误"></a>2003错误</h2><p>利用navicat for mysql 远程连接数据库时，输入主机名、密码以及端口后，连接测试时，出现<br>2003-Can’t connect to Mysql on ‘主机名’(10061)问题。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>原因是ubuntu系统的mysql不允许被远程连接操作，所以需要修改mysql配置文件。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote><ul><li>cd /etc/mysql</li><li>5.6版本及以下</li><li>vim my.cnf  bind-address = 127.0.0.1 改成 0.0.0.0</li><li>5.7版本及以上 </li><li>vim mysql.conf.d/mysqld.cnf bind-address = 127.0.0.1 改成 0.0.0.0</li><li>重启Mysql</li><li>service mysql restart</li></ul></blockquote><p>这样问题就解决了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL是流行的数据库系统，下面记录了在Ubuntu 16.04上安装MySQL步骤。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>杨辉三角</title>
    <link href="https://github.com/Livingston34/2018/03/05/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>https://github.com/Livingston34/2018/03/05/杨辉三角/</id>
    <published>2018-03-05T07:16:06.408Z</published>
    <updated>2018-03-05T08:29:27.825Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="杨辉"><a href="#杨辉" class="headerlink" title="杨辉"></a>杨辉</h1><p>南宋著名数学家,字谦光，汉族，钱塘（今浙江杭州）人，南宋杰出的数学家和数学教育家，生平履历不详。<br>曾担任过南宋地方行政官员，为政清廉，足迹遍及苏杭一带。<br>他在总结民间乘除捷算法、“垛积术”、纵横图以及数学教育方面，均做出了重大的贡献。他是世界上第一个<br>排出丰富的纵横图和讨论其构成规律的数学家。著有数学著作5种21卷，即《详解九章算法》12卷（1261），<br>《日用算法》2卷（1262），《乘除通变本末》3卷（1274），《田亩比类乘除捷法》2卷（1275）和<br>《续古摘奇算法》2卷（1275）（其中《详解》和《日用算法》已非完书）。后三种合称为《杨辉算法》。<br>朝鲜、日本等国均有译本出版，流传世界。<br><a id="more"></a></p><h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><p>杨辉三角是我国古代数学中一颗明珠，它最本质的特征是，它的两条斜边都是由数字1组成的，而其余的数<br>则是等于它肩上的两个数之和。 </p><p><img src="http://www.mux5.com/picture/29e1c698d098d760dfffa1bc347793502.jpg" alt="经典图例"></p><h2 id="坐标三角值"><a href="#坐标三角值" class="headerlink" title="坐标三角值"></a>坐标三角值</h2><blockquote><p>设杨辉三角中行号为i，列号为j，要求实现输入一组行号i，j，输出对应位置的杨辉三角值。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>其两大要素为递归函数以及递归出口。杨辉三角规律当前值等于两肩之和，此即递归函数，<br>递归出口为杨辉三角塔顶值为1。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//递归函数</span><br><span class="line">public static int yang(int i, int j)&#123;</span><br><span class="line">    // 赋初值为1</span><br><span class="line">    if(i == 0 &amp;&amp; j == 0) return 1;</span><br><span class="line">    // 越界非法值为0</span><br><span class="line">    if(j &lt; 0 || j &gt; i) return 0;</span><br><span class="line">    // 杨辉三角值递归计算</span><br><span class="line">    return yang(i - 1, j - 1) + yang(i - 1, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><blockquote><p>7, 6</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><blockquote><p>7</p></blockquote><h2 id="打印金字塔"><a href="#打印金字塔" class="headerlink" title="打印金字塔"></a>打印金字塔</h2><blockquote><p>输入行号n（起始值为0），打印输出n+1行的杨辉三角金字塔结构。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>直接结构循环打印</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 杨辉三角函数</span><br><span class="line">public void yangPrint(int n) &#123;</span><br><span class="line">    int count = n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        // 打印金字塔控制</span><br><span class="line">        for (int t = count; t &gt; 0; t--) &#123;</span><br><span class="line">            System.out.print(&quot;  &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        // 打印杨辉三角值</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            int m = yang(i, j);</span><br><span class="line">            if (m == 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                System.out.print(&quot; &quot; + m + &quot;  &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 换行</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h3><blockquote><p>7</p></blockquote><h3 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            1  </span><br><span class="line">          1   1  </span><br><span class="line">        1   2   1  </span><br><span class="line">      1   3   3   1  </span><br><span class="line">    1   4   6   4   1  </span><br><span class="line">  1   5   10   10   5   1  </span><br><span class="line">1   6   15   20   15   6   1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;杨辉&quot;&gt;&lt;a href=&quot;#杨辉&quot; class=&quot;headerlink&quot; title=&quot;杨辉&quot;&gt;&lt;/a&gt;杨辉&lt;/h1&gt;&lt;p&gt;南宋著名数学家,字谦光，汉族，钱塘（今浙江杭州）人，南宋杰出的数学家和数学教育家，生平履历不详。&lt;br&gt;曾担任过南宋地方行政官员，为政清廉，足迹遍及苏杭一带。&lt;br&gt;他在总结民间乘除捷算法、“垛积术”、纵横图以及数学教育方面，均做出了重大的贡献。他是世界上第一个&lt;br&gt;排出丰富的纵横图和讨论其构成规律的数学家。著有数学著作5种21卷，即《详解九章算法》12卷（1261），&lt;br&gt;《日用算法》2卷（1262），《乘除通变本末》3卷（1274），《田亩比类乘除捷法》2卷（1275）和&lt;br&gt;《续古摘奇算法》2卷（1275）（其中《详解》和《日用算法》已非完书）。后三种合称为《杨辉算法》。&lt;br&gt;朝鲜、日本等国均有译本出版，流传世界。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>冒泡排序(Bubble Sort)</title>
    <link href="https://github.com/Livingston34/2018/03/05/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F(Bubble%20Sort)/"/>
    <id>https://github.com/Livingston34/2018/03/05/冒泡排序(Bubble Sort)/</id>
    <published>2018-03-05T05:05:04.040Z</published>
    <updated>2018-03-05T05:45:02.538Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。<br>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。<br>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。<br><a id="more"></a></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元<br>  素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul></blockquote><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，<br>将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较<br>最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。</p><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><blockquote><p>排序数组：int[] arr = {6, 3, 5, 2, 11, 7};</p></blockquote><ul><li><p>第一趟排序：<br>  第一次排序：6和3比较，6大于3，交换位置：      3  6  5  2  11  7<br>　　第二次排序：6和5比较，6大于5，交换位置：      3  5  6  2  11  9<br>　　第三次排序：6和2比较，6大于2，交换位置：      3  5  2  6  11  9<br>　　第四次排序：6和11比较，6小于11，不交换位置：  3  5  2  6  11  9<br>　　第五次排序：11和9比较，11大于9，交换位置：    3  5  2  6  9   11<br>  第一趟总共进行了5次比较， 排序结果：          3  5  2  6  9   11</p></li><li><p>第二趟排序：<br>  第一次排序：3和5比较，3小于5，不交换位置：    3  5  2  6  9   11<br>  第二次排序：5和2比较，5大于2，交换位置：      3  2  5  6  9   11<br>  第三次排序：5和6比较，5小于6，不交换位置：    3  2  5  6  9   11<br>  第四次排序：6和9比较，6小于9，不交换位置：    3  2  5  6  9   11<br>  第二趟总共进行了4次比较， 排序结果：          3  2  5  6  9   11</p></li><li><p>第三趟排序：<br>  第一次排序：3和2比较，3大于2，交换位置：      2  3  5  6  9   11<br>  第二次排序：3和5比较，3小于5，不交换位置：    2  3  5  6  9   11<br>  第三次排序：5和6比较，5小于6，不交换位置：    2  3  5  6  9   11<br>  第三趟总共进行了3次比较， 排序结果：          2  3  5  6  9   11</p></li><li><p>第四趟排序：<br>  第一次排序：2和3比较，2小于3，不交换位置：    2  3  5  6  9   11<br>  第二次排序：3和5比较，3小于5，不交换位置：    2  3  5  6  9   11<br>  第四趟总共进行了2次比较， 排序结果：          2  3  5  6  9   11</p></li><li><p>第五趟排序：<br>  第一次排序：2和3比较，2小于3，不交换位置：    2  3  5  6  9   11<br>  第五趟总共进行了1次比较， 排序结果：          2  3  5  6  9   11</p></li></ul><blockquote><p>最终结果：2  3  5  6  9  11</p></blockquote><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>由此可见：N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">for (int j = 1; j &lt; arr.length -i ; j++) &#123;</span><br><span class="line">// 交换位置</span><br><span class="line">if (arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">int temp = arr[j];</span><br><span class="line">arr[j] = arr[j+1];</span><br><span class="line">arr[j+1] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h1><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中<br>是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求<br>排列好，可立即结束排序，避免不必要的比较过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean exchange = true;</span><br><span class="line">for (int i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">exchange = false;</span><br><span class="line">for (int j = 1; j &lt; arr.length -i ; j++) &#123;</span><br><span class="line">// 交换位置</span><br><span class="line">if (arr[j] &gt; arr[j+1]) &#123;</span><br><span class="line">int temp = arr[j];</span><br><span class="line">arr[j] = arr[j+1];</span><br><span class="line">arr[j+1] = temp;</span><br><span class="line">exchange = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!exchange) break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。&lt;br&gt;走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。&lt;br&gt;这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>环形加油站问题</title>
    <link href="https://github.com/Livingston34/2018/03/02/%E7%8E%AF%E5%BD%A2%E5%8A%A0%E6%B2%B9%E7%AB%99%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/Livingston34/2018/03/02/环形加油站问题/</id>
    <published>2018-03-02T07:21:51.806Z</published>
    <updated>2018-03-02T07:41:51.918Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油gas[i]，并且从第_i_个加油站前往第_i_+1个加油站需要消耗汽油cost[i]。<br>你有一辆油箱容量无限大的汽车，现在要从某一个加油站出发绕环路一周，一开始油箱为空。<br>求可环绕环路一周时出发的加油站的编号，若不存在环绕一周的方案，则返回-1。</p><a id="more"></a><blockquote><p>数据保证答案唯一。</p></blockquote><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><p>现在有4个加油站，汽油量gas[i]=[1, 1, 3, 1]，环路旅行时消耗的汽油量cost[i]=[2, 2, 1, 1]。则出发的加油站的编号为2。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>只要总汽油量要大于总的消耗量，那么肯定是有解的，可以从头遍历起，什么时候汽油量小于消耗量了，就假设从下一个点重新开始。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">    int n = gas.length;</span><br><span class="line">    int index, sum, total;</span><br><span class="line">    index = sum = total = 0;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        total += gas[i] - cost[i];</span><br><span class="line">        sum += gas[i] - cost[i];</span><br><span class="line">        if (sum &gt;= 0) continue;</span><br><span class="line">        sum = 0;</span><br><span class="line">        index = i + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(total &gt;= 0 ? index : -1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油gas[i]，并且从第_i_个加油站前往第_i_+1个加油站需要消耗汽油cost[i]。&lt;br&gt;你有一辆油箱容量无限大的汽车，现在要从某一个加油站出发绕环路一周，一开始油箱为空。&lt;br&gt;求可环绕环路一周时出发的加油站的编号，若不存在环绕一周的方案，则返回-1。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo插入音频和视频</title>
    <link href="https://github.com/Livingston34/2018/03/01/Hexo%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%E5%92%8C%E8%A7%86%E9%A2%91/"/>
    <id>https://github.com/Livingston34/2018/03/01/Hexo插入音乐和视频/</id>
    <published>2018-03-01T08:47:51.370Z</published>
    <updated>2018-03-04T15:18:50.136Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>通过hexo插件给自家的博客添加音乐和视频<br><a id="more"></a></p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>这里需要使用两个播放器插件</p><blockquote><p>hexo-tag-aplayer<br>  hexo-tag-dplayer</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>npm install hexo-tag-aplayer –save<br>  npm install hexo-tag-dplayer –save</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>以下是插件的基本使用</p><h2 id="插入音频"><a href="#插入音频" class="headerlink" title="插入音频"></a>插入音频</h2><blockquote><p>其中author, title 前两个标签必须添加，不然报错，图片可以不用添加</p></blockquote><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;%  aplayer</span><br><span class="line">    &quot;secret base~君がくれたもの~&quot;</span><br><span class="line">    &quot;茅野愛衣&quot;</span><br><span class="line">    &quot;https://moeplayer.b0.upaiyun.com/aplayer/secretbase.mp3&quot; </span><br><span class="line">    &quot;https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg&quot;</span><br><span class="line">    &quot;autoplay=false&quot; </span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div><script>var ap = new APlayer({element: document.getElementById("aplayer0"),narrow: false,autoplay: true,showlrc: 0,music: {title: "secret base~君がくれたもの~",author: "茅野愛衣",url: "http://sc1.111ttt.cn:8282/2017/1/11m/11/304112002347.m4a?tflag=1519095601&pin=6cd414115fdb9a950d827487b16b5f97",pic: "https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><div id="aplayer1" class="aplayer" style="margin-bottom: 20px;"></div><script>var options = {"narrow":false,"autoplay":false,"showlrc":0,"music":[{"title":"Même si c'est très loin","author":"Fréro Delavega","url":"http://sc1.111ttt.cn:8282/2017/1/11m/11/304112002347.m4a?tflag=1519095601&pin=6cd414115fdb9a950d827487b16b5f97","pic":""},{"title":"Säkkijärven polkka","author":"浜口史郎","url":"http://sc1.111ttt.cn:8282/2017/1/11m/11/304112002347.m4a?tflag=1519095601&pin=6cd414115fdb9a950d827487b16b5f97","pic":""}]};options.element = document.getElementById("aplayer1");var ap = new APlayer(options);window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% </span><br><span class="line">dplayer </span><br><span class="line">&quot;url=http://static.smartisanos.cn/common/video/video-jgpro.mp4&quot;  </span><br><span class="line">&quot;pic=http://home.ustc.edu.cn/~mmmwhy/GEM.jpg&quot; </span><br><span class="line">&quot;loop=yes&quot; </span><br><span class="line">&quot;theme=#FADFA3&quot; </span><br><span class="line">&quot;autoplay=false&quot; </span><br><span class="line">&quot;token=tokendemo&quot; </span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"red","loop":true,"volume":1,"mutex":true,"video":{"url":"http://static.smartisanos.cn/common/video/video-jgpro.mp4","pic":"http://home.ustc.edu.cn/~mmmwhy/GEM.jpg","thumbnails":"https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);player.on("loadstart",function(){console.log("loadstart")})})()</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过hexo插件给自家的博客添加音乐和视频&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="https://github.com/Livingston34/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Hexo" scheme="https://github.com/Livingston34/tags/Hexo/"/>
    
      <category term="音乐" scheme="https://github.com/Livingston34/tags/%E9%9F%B3%E4%B9%90/"/>
    
      <category term="视频" scheme="https://github.com/Livingston34/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>3分狂人杰克.海利</title>
    <link href="https://github.com/Livingston34/2018/03/01/3%E5%88%86%E7%8B%82%E4%BA%BA%E6%9D%B0%E5%85%8B.%E6%B5%B7%E5%88%A9/"/>
    <id>https://github.com/Livingston34/2018/03/01/3分狂人杰克.海利/</id>
    <published>2018-03-01T06:59:20.979Z</published>
    <updated>2018-03-01T08:18:31.375Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在NBA这个残酷的赛场上，优胜劣汰是常态，若想在继续生存加强自己的实力无疑是最佳选择，而说到在NBA生存，<br>那么最牛逼的存在就是——杰克.海利。10年的NBA生涯场均上场9.6分钟，仅仅得到3.5分2.7篮板。你能够想象?　<br><a id="more"></a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h314/20180228/nzGV-fyrwsqk1300553.jpg" alt="杰克.海利" title="">                </div>                <div class="image-caption">杰克.海利</div>            </figure></p><p>说到这里就不得不说我湖的萨队，生涯场均上场14分钟也仅仅得到4.2分3.1篮板。两人真的是“情投意合”啊。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h432/20180228/0hYC-fyrwsqk1300633.jpg" alt="挥毛巾的萨队" title="">                </div>                <div class="image-caption">挥毛巾的萨队</div>            </figure><br>然而萨队4个赛季后就不得不离开NBA这个大家庭，起驾去了日本联赛去挣奶粉钱了。是离愁。别是一般滋味在心头。<br>久久的萦绕在萨队的耳边。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h326/20180228/OOQs-fyrwsqk1300717.jpg" alt="日本联赛的萨队" title="">                </div>                <div class="image-caption">日本联赛的萨队</div>            </figure></p><h1 id="身世"><a href="#身世" class="headerlink" title="身世"></a>身世</h1><blockquote><p> 海利是一个星二代，父亲是加州冲浪界元老级人物，曾经夺得全美冲浪冠军，后靠名气开了冲浪饭店、餐馆。当然也是一个富二代。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h424/20180228/IVzM-fyrwsqk1300911.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="生涯"><a href="#生涯" class="headerlink" title="生涯"></a>生涯</h1><p>生涯总得分1180分，总篮板922个，很多球员在一个赛季里就能完成的数据，可他用了近10个赛季。</p><h1 id="选秀"><a href="#选秀" class="headerlink" title="选秀"></a>选秀</h1><p>1987年，第4轮79顺位被公牛选中。虽然自己的选秀不太靠前，但是那个神一样的男人却经常邀请海利参加自己的牌局。至于为什么？就靠各位阅读大大自己脑部了吧。（PS别想歪了）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h341/20180228/kGto-fyrwsqk1300969.jpg" alt="来打牌" title="">                </div>                <div class="image-caption">来打牌</div>            </figure><h1 id="和砍52分"><a href="#和砍52分" class="headerlink" title="和砍52分"></a>和砍52分</h1><p>进入NBA后的第一场比赛，海利上场了1分钟，赛后他说到：“我和乔丹合砍了52分”，也许你们都想知道他得了多少分吧？<br>实话告诉你们吧，那场比赛乔丹砍了52分。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h359/20180228/0zBI-fyrwsqk1301206.jpg" alt="我和乔丹合砍了52分" title="">                </div>                <div class="image-caption">我和乔丹合砍了52分</div>            </figure><h1 id="情定大虫"><a href="#情定大虫" class="headerlink" title="情定大虫"></a>情定大虫</h1><p>海利是个个性温顺，易招呼，家境殷实的2米08大个子，同时他也是大家眼中最受欢迎的角色，众所周知他与大虫罗德曼之间<br>那难舍难分的基友情。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h421/20180228/qvs9-fyrwsqk1301247.jpg" alt="一辈子，只搞基" title="">                </div>                <div class="image-caption">一辈子，只搞基</div>            </figure><h2 id="大虫"><a href="#大虫" class="headerlink" title="大虫"></a>大虫</h2><p>不论在球场内外，罗德曼都是一个不好管束的刺头，他身上处处都彰显着，老子不好惹，老子就是天下无敌。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h367/20180228/4N2N-fyrwsqk1301319.jpg" alt="老子就是天下无敌" title="">                </div>                <div class="image-caption">老子就是天下无敌</div>            </figure><h2 id="圣安东尼奥"><a href="#圣安东尼奥" class="headerlink" title="圣安东尼奥"></a>圣安东尼奥</h2><p>1993年10月，在汽车城沉淀了7个赛季的罗德曼，来到了圣安东尼奥，场均不足5分的海利，在辗转于公牛，<br>篮网、湖人之后。与罗德曼成为了队友。开启了基情列车的引擎。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h341/20180228/oQ9F-fyrwsqk1301481.jpg" alt="上车了，老司机带你" title="">                </div>                <div class="image-caption">上车了，老司机带你</div>            </figure><p>想当年罗德曼场均能抢下18个篮板，已经是联盟头号篮板手，简直就是一个篮板怪兽。然而他的性格让人实在<br>头疼，与人相处都很难。管理层希望人缘好的海利，能和罗德曼打成一片，帮助他早日融入球队，但是罗德曼<br>当时不削看海利一眼更别提说话了。</p><h2 id="篮板事件"><a href="#篮板事件" class="headerlink" title="篮板事件"></a>篮板事件</h2><p>由于罗德曼很在乎自己的篮板数，很多时候都怀疑统计员总是少记录了他的篮板数，经常为此大动肝火。<br>海利注意到了这点，就在场下默默的记下了他的篮板数，有一场比赛，罗德曼直接冲过来问海利：“我抢了几个<br>板了”。从那时起，罗德曼就慢慢接纳了这个温顺的大个子。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h364/20180228/NBOl-fyrwsqk1301902.jpg" alt="基情含苞待放" title="">                </div>                <div class="image-caption">基情含苞待放</div>            </figure><h2 id="车速太快"><a href="#车速太快" class="headerlink" title="车速太快"></a>车速太快</h2><p>第一次跟海利一起出去，罗德曼就选了一个gay吧，两个人在gay吧里嗨了一晚上。俗话说：“爱他，就要接受他<br>的全部”（自行脑补）。自从“那一次”后，罗德曼一改冷淡作风，竟然说海利“像是一只粘人的小狗”。球队比赛<br>的时候，罗德曼都会要求球队为他和海利，订有两张床的套房。（此时小编有点不理解，不是爱他吗？为什么要<br>两张床？）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1519897733890&di=d7f976fefaa861b887792a6e0ffd67a3&imgtype=0&src=http%3A%2F%2Fimage.uczzd.cn%2F1176643674952898629.jpg%3Fid%3D0%26from%3Dexport" alt="杨氏疑惑" title="">                </div>                <div class="image-caption">杨氏疑惑</div>            </figure><h2 id="芝加哥"><a href="#芝加哥" class="headerlink" title="芝加哥"></a>芝加哥</h2><p>1995年10月，罗德曼被公牛招致麾下，为了保险起见他们一并签下了身为自由球员的海利。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w547h567/20180228/wru0-fyrwsqk1302126.jpg" alt="肚子这么大几个月了" title="">                </div>                <div class="image-caption">肚子这么大几个月了</div>            </figure><p>这时海利的人格魅力就展现得淋漓尽致，他告诉罗德曼只要赢下这一场，就有各种各样的“party”等着他，将海利<br>视为“挚爱”的罗德曼，听从了海利的规劝回到了比赛场。</p><p>就在总决赛第6场，连胜2场的超音速来势汹汹，加上佩顿主动要求防守乔丹，当时的乔丹被防的相当难受，19投5中<br>只得到22分，跟前几场相比大打折扣。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w480h356/20180228/y3IK-fyrwsqk1302320.jpg" alt="佩顿防守乔丹" title="">                </div>                <div class="image-caption">佩顿防守乔丹</div>            </figure><p>这场比赛罗德曼却发挥了极大的作用，他抢下19个篮板，其中11个进攻篮板，并让与其对位的坎普6犯离场。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h551/20180228/R8GY-fyrwsqk1300426.jpg" alt="怒抓一篮板" title="">                </div>                <div class="image-caption">怒抓一篮板</div>            </figure><p>超音速主教练乔治·卡尔道：“罗德曼是他们拿下胜利的主要因素，他抢的篮板给他们制造了更多的得分机会”。<br>最终公牛4-2战胜超音速拿下总冠军。其中与海利也有莫大的关联。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h340/20180228/bsn0-fyrwsqk1300573.jpg" alt="怒拿一冠军" title="">                </div>                <div class="image-caption">怒拿一冠军</div>            </figure><h1 id="退役"><a href="#退役" class="headerlink" title="退役"></a>退役</h1><p>渐渐地海利淡出了NBA赛场，原公牛队主教练道格-柯林斯回忆到：“虽然经常没有机会上场，但他永远坐在离我最近<br>的地方，他想让我需要人的时候就想到他，他永远准备好上场，永远渴望比赛”。退役后他做过篮网的助理教练做过<br>赛前采访，同样不想离开篮球。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w531h321/20180228/3jQo-fyrwsqk1300811.jpg" alt="我是一名篮球手，只有我的队友知道我每天有多努力" title="">                </div>                <div class="image-caption">我是一名篮球手，只有我的队友知道我每天有多努力</div>            </figure><p>虽然海利在球场上的表现平淡无奇，但他却使用另一种方式让自己离最喜欢的球场更近一步，这何尝不是一段成功的<br>经历呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://n.sinaimg.cn/sports/crawl/w550h400/20180228/Zuzc-fyrwsqk1300918.jpg" alt="他的成功" title="">                </div>                <div class="image-caption">他的成功</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在NBA这个残酷的赛场上，优胜劣汰是常态，若想在继续生存加强自己的实力无疑是最佳选择，而说到在NBA生存，&lt;br&gt;那么最牛逼的存在就是——杰克.海利。10年的NBA生涯场均上场9.6分钟，仅仅得到3.5分2.7篮板。你能够想象?　&lt;br&gt;
    
    </summary>
    
      <category term="NBA" scheme="https://github.com/Livingston34/categories/NBA/"/>
    
    
      <category term="NBA" scheme="https://github.com/Livingston34/tags/NBA/"/>
    
      <category term="人缘" scheme="https://github.com/Livingston34/tags/%E4%BA%BA%E7%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>快速排序法</title>
    <link href="https://github.com/Livingston34/2018/02/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95/"/>
    <id>https://github.com/Livingston34/2018/02/28/快速排序法/</id>
    <published>2018-02-28T08:00:05.269Z</published>
    <updated>2018-02-28T08:11:46.315Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>快速排序（Quicksort）是对冒泡排序的一种改进。</p><p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><a id="more"></a><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题案例"><a href="#试题案例" class="headerlink" title="试题案例"></a>试题案例</h1><p>设一组初始记录关键字序列为（49、38、65、97、76、13、27、49），则以第一个关键字49为基准而得到的一趟快速排序结果是（）</p><blockquote><p>A. 38，13，27，49，49，65，97，76<br>  B. 13，27，38，49，65，76，97，49<br>  C. 27，38，13，49，76，97，65，49<br>  D. 27，38，13，49，97，76，65，49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序（Quicksort）是对冒泡排序的一种改进。&lt;/p&gt;
&lt;p&gt;快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找法</title>
    <link href="https://github.com/Livingston34/2018/02/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>https://github.com/Livingston34/2018/02/28/二分查找法/</id>
    <published>2018-02-28T07:37:40.850Z</published>
    <updated>2018-02-28T08:11:41.967Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。<br><a id="more"></a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ol><li>必须采用顺序存储结构。</li><li>必须按关键字大小有序排列。</li></ol><h1 id="比较次数"><a href="#比较次数" class="headerlink" title="比较次数"></a>比较次数</h1><blockquote><p>计算公式：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D182/sign=e04907e14190f60300b0984f0b10b370/09fa513d269759ee57a6eb1bb9fb43166c22df68.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>  当顺序表有n个关键字时：<br>  查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。<br>  注意：a,b,n均为正整数。</p></blockquote><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearch(Integer[] srcArray, int des) &#123;</span><br><span class="line">    // 定义初始最小、最大索引</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = srcArray.length - 1;</span><br><span class="line">    // 确保不会出现重复查找，越界</span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        // 计算出中间索引值</span><br><span class="line">        int middle = (high + low)&gt;&gt;&gt;1 ;//防止溢出</span><br><span class="line">        if (des == srcArray[middle]) &#123;</span><br><span class="line">            return middle;</span><br><span class="line">        // 判断下限</span><br><span class="line">        &#125; else if (des &lt; srcArray[middle]) &#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        // 判断上限</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若没有，则返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题案例"><a href="#试题案例" class="headerlink" title="试题案例"></a>试题案例</h1><p>设有一组关键字序列{5，8，14，20，31，55，78，81，93，97，111}，使用二分（折半）法查找关键字93需要进行多少次比较（A）</p><blockquote><p>A. 2<br>  B. 3<br>  C. 4<br>  D. 5</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>索引为0-10 </li><li>第一次 left=0,right=10,mid=(left+right)/2=5; 索引为5的为55</li><li>第二次 left=mid+1=6 ,right=10;mid=(left+right)/2=8;索引为8的为93.到此比较完毕 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>搜狐2016招聘笔试题（扎金花）</title>
    <link href="https://github.com/Livingston34/2018/02/28/%E6%90%9C%E7%8B%902016%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%89%8E%E9%87%91%E8%8A%B1%EF%BC%89/"/>
    <id>https://github.com/Livingston34/2018/02/28/搜狐2016招聘笔试题（扎金花）/</id>
    <published>2018-02-28T07:19:04.585Z</published>
    <updated>2018-02-28T07:22:33.961Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>两个搜狐的程序员加了一个月班，终于放假了，于是他们决定扎金花渡过愉快的假期 。<br><a id="more"></a></p><h1 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h1><p>共52张普通牌，牌面为2,3,4,5,6,7,8,9,10,J,Q,K,A之一，大小递增，各四张； 每人抓三张牌。两人比较手中三张牌大小，大的人获胜。</p><p>对于牌型的规则如下:</p><blockquote><p>1.三张牌一样即为豹子<br>  2.三张牌相连为顺子（A23不算顺子）<br>  3.有且仅有两张牌一样为对子 豹子&gt;顺子&gt;对子&gt;普通牌型 在牌型一样时，比较牌型数值大小（如AAA&gt;KKK,QAK&gt;534，QQ2&gt;10104） 在二人均无特殊牌型时，依次比较三张牌中最大的。大的人获胜，如果最大的牌一样，则比较第二大，以此类推（如37K&gt;89Q） 如二人牌面相同，则为平局。</p></blockquote><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>输入两个字符串代表两个玩家的牌（如”10KQ” “354”），先输入的作为玩家1，后输入的作为玩家2</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>1 代表 玩家1赢 0 代表 平局 -1 代表 玩家2赢 -2 代表不合法的输入</p></blockquote><h1 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h1><blockquote><p>KQ3 3Q9<br>  10QA 6102<br>  5810 7KK<br>  632 74J<br>  10102 K77<br>  JKJ 926<br>  68K 27A</p></blockquote><h1 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h1><blockquote><p>1<br>  1<br>  -1<br>  -1<br>  1<br>  1<br>  -1</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个搜狐的程序员加了一个月班，终于放假了，于是他们决定扎金花渡过愉快的假期 。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="搜狐" scheme="https://github.com/Livingston34/tags/%E6%90%9C%E7%8B%90/"/>
    
      <category term="笔试" scheme="https://github.com/Livingston34/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>美团2017校招笔试（最大矩形面积）</title>
    <link href="https://github.com/Livingston34/2018/02/28/%E7%BE%8E%E5%9B%A22017%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%89/"/>
    <id>https://github.com/Livingston34/2018/02/28/美团2017校招笔试（最大矩形面积）/</id>
    <published>2018-02-28T06:47:41.006Z</published>
    <updated>2018-02-28T06:57:43.063Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>给定一组非负整数组成的数组h，代表一组柱状图的高度，其中每个柱子的宽度都为1。 在这组柱状图中找到能组成的最大矩形的面积（如图所示）。 入参h为一个整型数组，代表每个柱子的高度，返回面积的值。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploadfiles.nowcoder.com/images/20170726/58_1501040380059_47BE7E63FCFEB94676970280264AA19A" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>输入包括两行,第一行包含一个整数n(1 ≤ n ≤ 10000)<br>  第二行包括n个整数,表示h数组中的每个值,h_i(1 ≤ h_i ≤ 1,000,000)</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>输出一个整数,表示最大的矩阵面积。</p></blockquote><h1 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h1><blockquote><p>6<br>  2 1 5 6 2 3</p></blockquote><h1 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h1><blockquote><p>10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一组非负整数组成的数组h，代表一组柱状图的高度，其中每个柱子的宽度都为1。 在这组柱状图中找到能组成的最大矩形的面积（如图所示）。 入参h为一个整型数组，代表每个柱子的高度，返回面积的值。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="https://github.com/Livingston34/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="美团" scheme="https://github.com/Livingston34/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>美团2017校招笔试（大富翁游戏）</title>
    <link href="https://github.com/Livingston34/2018/02/28/%E7%BE%8E%E5%9B%A22017%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E5%A4%A7%E5%AF%8C%E7%BF%81%E6%B8%B8%E6%88%8F%EF%BC%89/"/>
    <id>https://github.com/Livingston34/2018/02/28/美团2017校招笔试（大富翁游戏）/</id>
    <published>2018-02-28T03:31:19.985Z</published>
    <updated>2018-02-28T08:56:31.802Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n&lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。<br><a id="more"></a></p><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>输入包括一个整数n,(1 ≤ n ≤ 6)</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>输出一个整数,表示投骰子的方法</p></blockquote><h1 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h1><blockquote><p>6</p></blockquote><h1 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h1><blockquote><p>32</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote><p>f(n)=f(n-1)+f(n-2)+…+1;<br>  在玩家走到第n步的情况，<br>  可能是先走了n-1步，剩下1步到达；<br>  也可能是先走n-2步，剩下再走2步到达；<br>  …；<br>  也可能是先走了1步，剩下再走n-1步。</p></blockquote><p>  即 f(n) 是f(n-1)…f(1)的情况相加，再加上最后一步。<br>  则f(n) = f(n-1) + f(n-2) + … + f(1) + 1</p><h1 id="计算通项式"><a href="#计算通项式" class="headerlink" title="计算通项式"></a>计算通项式</h1><blockquote><p>① f(n) = f(n-1) + f(n-2) + … + f(1) + 1<br>  ② f(n-1) = f(n-2) + f(n-3) + … + f(1) + 1<br>  那么② - ①得出 f(n) = 2 * f(n-1)<br>  利用数列的递推公式<br>  f(n) / f(n-1) = 2;<br>  f(n-1) / f(n-2) = 2;<br>  …<br>  f(2) / f(1) = 2;<br>  相乘后f(n) / f(1) = 2^(n-1)<br>  由于f(1) = 1<br>  所以f(n) = 2^(n-1)</p></blockquote><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public long monopoly(int step) &#123;</span><br><span class="line">    return (long) Math.pow(2 , step - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;  </span><br><span class="line">    System.out.println(&quot;投骰子的方法有&quot; + monopoly(6) + &quot;种&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n&amp;lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="https://github.com/Livingston34/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="美团" scheme="https://github.com/Livingston34/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>美团2016招聘笔试（股票交易日）</title>
    <link href="https://github.com/Livingston34/2018/02/28/%E7%BE%8E%E5%9B%A22016%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%EF%BC%88%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E6%97%A5%EF%BC%89/"/>
    <id>https://github.com/Livingston34/2018/02/28/美团2016招聘笔试（股票交易日）/</id>
    <published>2018-02-28T03:19:42.542Z</published>
    <updated>2018-02-28T06:48:37.964Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用实践复杂度低的方法实现。<br><a id="more"></a></p><blockquote><p>给定价格序列prices及它的长度n，请返回最大收益。保证长度小于等于500。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用实践复杂度低的方法实现。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://github.com/Livingston34/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://github.com/Livingston34/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="https://github.com/Livingston34/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="美团" scheme="https://github.com/Livingston34/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>JAVA经典试题四十道</title>
    <link href="https://github.com/Livingston34/2018/02/26/JAVA%E7%BB%8F%E5%85%B8%E8%AF%95%E9%A2%98%E5%9B%9B%E5%8D%81%E9%81%93/"/>
    <id>https://github.com/Livingston34/2018/02/26/JAVA经典试题四十道/</id>
    <published>2018-02-26T08:44:56.862Z</published>
    <updated>2018-02-26T09:50:23.900Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><a id="more"></a><h1 id="1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"><a href="#1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？" class="headerlink" title="1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"></a>1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</h1><blockquote><p>分析：兔子的规律为数列1,1,2,3,5,8,13,21…. </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 递归方式实现</span><br><span class="line"> */</span><br><span class="line">public int fibonacci(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递推方式实现</span><br><span class="line"> */</span><br><span class="line">public int fibonacciNormal(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // r1 幼兔 r2 成年兔</span><br><span class="line">    int r1 = 1, r2 = 1, sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n - 2; i++) &#123;</span><br><span class="line">        sum = r1 + r2;</span><br><span class="line">        r1 = r2;</span><br><span class="line">        r2 = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;  </span><br><span class="line">    System.out.println(&quot;递归方式实现：&quot; + fibonacci(8));  </span><br><span class="line">    System.out.println(&quot;递推方式实现：&quot; + fibonacciNormal(8));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:<br>递归方式实现：21<br>递推方式实现：21</p></blockquote><h1 id="2、判断101-200之间有多少个素数，并输出所有素数。"><a href="#2、判断101-200之间有多少个素数，并输出所有素数。" class="headerlink" title="2、判断101-200之间有多少个素数，并输出所有素数。"></a>2、判断101-200之间有多少个素数，并输出所有素数。</h1><blockquote><p>分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，<br>则表明此数不是素数，反之是素数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断是否为素数</span><br><span class="line"> */</span><br><span class="line">public boolean isPrimeNumber(int number) &#123;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    if (number == 1)</span><br><span class="line">        flag = false;</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int i = 2; i &lt;= Math.sqrt(number); i++) &#123;</span><br><span class="line">            if (number % i == 0 || number == 1) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;  </span><br><span class="line">    int start = 101;</span><br><span class="line">    int end = 200;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        if (!isPrimeNumber(i)) continue;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.print(i + &quot; &quot;);</span><br><span class="line">        if (count % 10 == 0) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:<br>101 103 107 109 113 127 131 137 139 149<br>151 157 163 167 173 179 181 191 193 197<br>199 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://github.com/Livingston34/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>淘宝IP地址库</title>
    <link href="https://github.com/Livingston34/2018/02/26/%E6%B7%98%E5%AE%9DIP%E5%9C%B0%E5%9D%80%E5%BA%93/"/>
    <id>https://github.com/Livingston34/2018/02/26/淘宝IP地址库/</id>
    <published>2018-02-26T06:11:35.485Z</published>
    <updated>2018-02-26T06:16:08.786Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>根据用户提供的IP地址，快速查询出该IP地址所在的地理信息和地理相关的信息，包括国家、省、市和运营商。<br>用户可以根据自己所在的位置和使用的IP地址更新我们的服务内容。</p><a id="more"></a><h1 id="请求接口（GET）"><a href="#请求接口（GET）" class="headerlink" title="请求接口（GET）"></a>请求接口（GET）</h1><blockquote><p><a href="http://ip.taobao.com/service/getIpInfo2.php?ip=[ip地址字串]" target="_blank" rel="noopener">http://ip.taobao.com/service/getIpInfo2.php?ip=[ip地址字串]</a></p></blockquote><h1 id="响应信息"><a href="#响应信息" class="headerlink" title="响应信息"></a>响应信息</h1><blockquote><p>（json格式的）国家 、省（自治区或直辖市）、市（县）、运营商</p></blockquote><h1 id="返回数据格式"><a href="#返回数据格式" class="headerlink" title="返回数据格式"></a>返回数据格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:0,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;ip&quot;:&quot;210.75.225.254&quot;,</span><br><span class="line">        &quot;country&quot;:&quot;中国&quot;,</span><br><span class="line">        &quot;area&quot;:&quot;华北&quot;,</span><br><span class="line">        &quot;region&quot;:&quot;北京市&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;北京市&quot;,</span><br><span class="line">        &quot;county&quot;:&quot;&quot;,</span><br><span class="line">        &quot;isp&quot;:&quot;电信&quot;,</span><br><span class="line">        &quot;country_id&quot;:&quot;86&quot;,</span><br><span class="line">        &quot;area_id&quot;:&quot;100000&quot;,</span><br><span class="line">        &quot;region_id&quot;:&quot;110000&quot;,</span><br><span class="line">        &quot;city_id&quot;:&quot;110000&quot;,</span><br><span class="line">        &quot;county_id&quot;:&quot;-1&quot;,</span><br><span class="line">        &quot;isp_id&quot;:&quot;100017&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中code的值的含义为，0：成功，1：失败。</p><h1 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h1><blockquote><p>为了保障服务正常运行，每个用户的访问频率需小于10qps。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据用户提供的IP地址，快速查询出该IP地址所在的地理信息和地理相关的信息，包括国家、省、市和运营商。&lt;br&gt;用户可以根据自己所在的位置和使用的IP地址更新我们的服务内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="淘宝" scheme="https://github.com/Livingston34/tags/%E6%B7%98%E5%AE%9D/"/>
    
      <category term="IP" scheme="https://github.com/Livingston34/tags/IP/"/>
    
      <category term="接口" scheme="https://github.com/Livingston34/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>将一个已存在的目录转换为一个 Git 项目并托管到 GitHub 仓库</title>
    <link href="https://github.com/Livingston34/2018/02/26/%E5%B0%86%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%AA%20Git%20%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%89%98%E7%AE%A1%E5%88%B0%20GitHub%20%E4%BB%93%E5%BA%93/"/>
    <id>https://github.com/Livingston34/2018/02/26/将一个已存在的目录转换为一个 Git 项目并托管到 GitHub 仓库/</id>
    <published>2018-02-26T03:00:07.994Z</published>
    <updated>2018-03-06T09:00:13.628Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>总共以下几个步骤：<br><a id="more"></a></p><blockquote><p>一、 打开命令行终端，进入项目所在的本地目录，将目录初始化为一个 Git 项目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>此时会在目录中创建一个 .git 隐藏文件夹</p><hr><blockquote><p>二、 将所有文件放进新的本地 git 仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>如果你本地已经有 .gitignore 文件，会按照已有规则过滤不需要添加的文件。如果不想要添加所有文件，可以把 . 符号换成具体的文件名</p><hr><blockquote><p>三、 将添加的文件提交到仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;comment&apos;</span><br></pre></td></tr></table></figure><hr><blockquote><p>四、 访问 GitHub</p></blockquote><hr><blockquote><p>五、 创建一个新仓库</p></blockquote><p>为了避免冲突，先不要勾选 README 和 LICENSE 选项</p><hr><blockquote><p>六、 在生成的项目主页上，复制仓库地址</p></blockquote><hr><blockquote><p>七、 回到命令行终端界面，将本地仓库关联到远程仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin ***.git</span><br></pre></td></tr></table></figure><p>可运行以下命令查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><blockquote><p>八、 提交代码到 GitHub 仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git branch -set-upstream-to=origin/master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总共以下几个步骤：&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://github.com/Livingston34/tags/Git/"/>
    
      <category term="GitHub" scheme="https://github.com/Livingston34/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>常用的抓包软件</title>
    <link href="https://github.com/Livingston34/2018/02/23/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6/"/>
    <id>https://github.com/Livingston34/2018/02/23/常用的抓包软件/</id>
    <published>2018-02-23T08:01:36.033Z</published>
    <updated>2018-03-01T03:41:40.749Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>做web开发或者app开发的时候，经常会有抓包的需求。下面总结一下我用过的抓包工具，并分析一下优缺点。<br><a id="more"></a></p><h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p>Wireshark一直是用的最爽的一个工具，在mac和windows下都有一致的界面。但是，Wireshark没有自带proxy，因此需要自己搭建proxy。</p><h1 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h1><p>最好用的抓包工具，支持https、proxy。但是是基于.Net 技术开发的，没办法直接在 Mac/Linux 下使用。</p><h1 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h1><p>自带proxy，支持拦截并修改response，非常好用的一个工具，支持mac。<br>但是只有30天试用，收费的是50刀。网上有免费得注册码。一个缺陷是，很容易丢包。<br>像高德地图的api一个都没抓到，百度地图的却都抓到了。<br>Charles支持Https抓包，但需要在手机上安装一个证书（如果不安转这个证书，在Charles中看到的request和response是乱码）</p><div id="aplayer2" class="aplayer" style="margin-bottom: 20px;"></div><script>var ap = new APlayer({element: document.getElementById("aplayer2"),narrow: false,autoplay: false,showlrc: 0,music: {title: "secret base~君がくれたもの~",author: "茅野愛衣",url: "https://moeplayer.b0.upaiyun.com/aplayer/secretbase.mp3",pic: "https://moeplayer.b0.upaiyun.com/aplayer/secretbase.jpg",}});window.aplayers || (window.aplayers = []);window.aplayers.push(ap);</script><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://d47jbcq60tnr6.cloudfront.net/201831/15801-zdprar.jpg" alt="新垣结衣" title="">                </div>                <div class="image-caption">新垣结衣</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做web开发或者app开发的时候，经常会有抓包的需求。下面总结一下我用过的抓包工具，并分析一下优缺点。&lt;br&gt;
    
    </summary>
    
      <category term="分享" scheme="https://github.com/Livingston34/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="软件" scheme="https://github.com/Livingston34/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="抓包" scheme="https://github.com/Livingston34/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
</feed>
