<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Livingston</title>
  
  <subtitle>“你没车没房没卡,拿什么和我谈恋爱？”“......我有高达......”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baidu.com/"/>
  <updated>2018-02-28T08:11:46.315Z</updated>
  <id>http://www.baidu.com/</id>
  
  <author>
    <name>杨霁</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速排序法</title>
    <link href="http://www.baidu.com/2018/02/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B3%95/"/>
    <id>http://www.baidu.com/2018/02/28/快速排序法/</id>
    <published>2018-02-28T08:00:05.269Z</published>
    <updated>2018-02-28T08:11:46.315Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序（Quicksort）是对冒泡排序的一种改进。</p><p>快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><a id="more"></a><h1 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h1><p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="试题案例"><a href="#试题案例" class="headerlink" title="试题案例"></a>试题案例</h1><p>设一组初始记录关键字序列为（49、38、65、97、76、13、27、49），则以第一个关键字49为基准而得到的一趟快速排序结果是（）</p><blockquote><p>A. 38，13，27，49，49，65，97，76<br>  B. 13，27，38，49，65，76，97，49<br>  C. 27，38，13，49，76，97，65，49<br>  D. 27，38，13，49，97，76，65，49</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序（Quicksort）是对冒泡排序的一种改进。&lt;/p&gt;
&lt;p&gt;快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.baidu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.baidu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找法</title>
    <link href="http://www.baidu.com/2018/02/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    <id>http://www.baidu.com/2018/02/28/二分查找法/</id>
    <published>2018-02-28T07:37:40.850Z</published>
    <updated>2018-02-28T08:11:41.967Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。<br><a id="more"></a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ol><li>必须采用顺序存储结构。</li><li>必须按关键字大小有序排列。</li></ol><h1 id="比较次数"><a href="#比较次数" class="headerlink" title="比较次数"></a>比较次数</h1><blockquote><p>计算公式：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/s%3D182/sign=e04907e14190f60300b0984f0b10b370/09fa513d269759ee57a6eb1bb9fb43166c22df68.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>  当顺序表有n个关键字时：<br>  查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。<br>  注意：a,b,n均为正整数。</p></blockquote><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static int binarySearch(Integer[] srcArray, int des) &#123;</span><br><span class="line">    // 定义初始最小、最大索引</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = srcArray.length - 1;</span><br><span class="line">    // 确保不会出现重复查找，越界</span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        // 计算出中间索引值</span><br><span class="line">        int middle = (high + low)&gt;&gt;&gt;1 ;//防止溢出</span><br><span class="line">        if (des == srcArray[middle]) &#123;</span><br><span class="line">            return middle;</span><br><span class="line">        // 判断下限</span><br><span class="line">        &#125; else if (des &lt; srcArray[middle]) &#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        // 判断上限</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若没有，则返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="试题案例"><a href="#试题案例" class="headerlink" title="试题案例"></a>试题案例</h1><p>设有一组关键字序列{5，8，14，20，31，55，78，81，93，97，111}，使用二分（折半）法查找关键字93需要进行多少次比较（A）</p><blockquote><p>A. 2<br>  B. 3<br>  C. 4<br>  D. 5</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>索引为0-10 </li><li>第一次 left=0,right=10,mid=(left+right)/2=5; 索引为5的为55</li><li>第二次 left=mid+1=6 ,right=10;mid=(left+right)/2=8;索引为8的为93.到此比较完毕 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.baidu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.baidu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>搜狐2016招聘笔试题（扎金花）</title>
    <link href="http://www.baidu.com/2018/02/28/%E6%90%9C%E7%8B%902016%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%E9%A2%98%EF%BC%88%E6%89%8E%E9%87%91%E8%8A%B1%EF%BC%89/"/>
    <id>http://www.baidu.com/2018/02/28/搜狐2016招聘笔试题（扎金花）/</id>
    <published>2018-02-28T07:19:04.585Z</published>
    <updated>2018-02-28T07:22:33.961Z</updated>
    
    <content type="html"><![CDATA[<p>两个搜狐的程序员加了一个月班，终于放假了，于是他们决定扎金花渡过愉快的假期 。<br><a id="more"></a></p><h1 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h1><p>共52张普通牌，牌面为2,3,4,5,6,7,8,9,10,J,Q,K,A之一，大小递增，各四张； 每人抓三张牌。两人比较手中三张牌大小，大的人获胜。</p><p>对于牌型的规则如下:</p><blockquote><p>1.三张牌一样即为豹子<br>  2.三张牌相连为顺子（A23不算顺子）<br>  3.有且仅有两张牌一样为对子 豹子&gt;顺子&gt;对子&gt;普通牌型 在牌型一样时，比较牌型数值大小（如AAA&gt;KKK,QAK&gt;534，QQ2&gt;10104） 在二人均无特殊牌型时，依次比较三张牌中最大的。大的人获胜，如果最大的牌一样，则比较第二大，以此类推（如37K&gt;89Q） 如二人牌面相同，则为平局。</p></blockquote><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>输入两个字符串代表两个玩家的牌（如”10KQ” “354”），先输入的作为玩家1，后输入的作为玩家2</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>1 代表 玩家1赢 0 代表 平局 -1 代表 玩家2赢 -2 代表不合法的输入</p></blockquote><h1 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h1><blockquote><p>KQ3 3Q9<br>  10QA 6102<br>  5810 7KK<br>  632 74J<br>  10102 K77<br>  JKJ 926<br>  68K 27A</p></blockquote><h1 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h1><blockquote><p>1<br>  1<br>  -1<br>  -1<br>  1<br>  1<br>  -1</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两个搜狐的程序员加了一个月班，终于放假了，于是他们决定扎金花渡过愉快的假期 。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.baidu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.baidu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="搜狐" scheme="http://www.baidu.com/tags/%E6%90%9C%E7%8B%90/"/>
    
      <category term="笔试" scheme="http://www.baidu.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>美团2017校招笔试（最大矩形面积）</title>
    <link href="http://www.baidu.com/2018/02/28/%E7%BE%8E%E5%9B%A22017%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%89/"/>
    <id>http://www.baidu.com/2018/02/28/美团2017校招笔试（最大矩形面积）/</id>
    <published>2018-02-28T06:47:41.006Z</published>
    <updated>2018-02-28T06:57:43.063Z</updated>
    
    <content type="html"><![CDATA[<p>给定一组非负整数组成的数组h，代表一组柱状图的高度，其中每个柱子的宽度都为1。 在这组柱状图中找到能组成的最大矩形的面积（如图所示）。 入参h为一个整型数组，代表每个柱子的高度，返回面积的值。<br><a id="more"></a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploadfiles.nowcoder.com/images/20170726/58_1501040380059_47BE7E63FCFEB94676970280264AA19A" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>输入包括两行,第一行包含一个整数n(1 ≤ n ≤ 10000)<br>  第二行包括n个整数,表示h数组中的每个值,h_i(1 ≤ h_i ≤ 1,000,000)</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>输出一个整数,表示最大的矩阵面积。</p></blockquote><h1 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h1><blockquote><p>6<br>  2 1 5 6 2 3</p></blockquote><h1 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h1><blockquote><p>10</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给定一组非负整数组成的数组h，代表一组柱状图的高度，其中每个柱子的宽度都为1。 在这组柱状图中找到能组成的最大矩形的面积（如图所示）。 入参h为一个整型数组，代表每个柱子的高度，返回面积的值。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.baidu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.baidu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="http://www.baidu.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="美团" scheme="http://www.baidu.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>美团2017校招笔试（大富翁游戏）</title>
    <link href="http://www.baidu.com/2018/02/28/%E7%BE%8E%E5%9B%A22017%E6%A0%A1%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E5%A4%A7%E5%AF%8C%E7%BF%81%E6%B8%B8%E6%88%8F%EF%BC%89/"/>
    <id>http://www.baidu.com/2018/02/28/美团2017校招笔试（大富翁游戏）/</id>
    <published>2018-02-28T03:31:19.985Z</published>
    <updated>2018-02-28T06:51:00.096Z</updated>
    
    <content type="html"><![CDATA[<p>大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n&lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。<br><a id="more"></a></p><h1 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h1><blockquote><p>输入包括一个整数n,(1 ≤ n ≤ 6)</p></blockquote><h1 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h1><blockquote><p>输出一个整数,表示投骰子的方法</p></blockquote><h1 id="输入例子"><a href="#输入例子" class="headerlink" title="输入例子"></a>输入例子</h1><blockquote><p>6</p></blockquote><h1 id="输出例子"><a href="#输出例子" class="headerlink" title="输出例子"></a>输出例子</h1><blockquote><p>32</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><blockquote><p>f(n)=f(n-1)+f(n-2)+…+1;<br>  在玩家走到第n步的情况，<br>  可能是先走了n-1步，剩下1步到达；<br>  也可能是先走n-2步，剩下再走2步到达；<br>  …；<br>  也可能是先走了1步，剩下再走n-1步。</p></blockquote><p>  即 f(n) 是f(n-1)…f(1)的情况相加，再加上最后一步。<br>  则f(n) = f(n-1) + f(n-2) + … + f(1) + 1</p><h1 id="计算通项式"><a href="#计算通项式" class="headerlink" title="计算通项式"></a>计算通项式</h1><blockquote><p>f(n) = f(n-1) + f(n-2) + … + f(1) + 1  ①<br>  f(n-1) = f(n-2) + f(n-3) + … + f(1) + 1  ②<br>  那么② - ①得出 f(n) = 2 * f(n-1)<br>  利用数列的递推公式<br>  f(n) / f(n-1) = 2;<br>  f(n-1) / f(n-2) = 2;<br>  …<br>  f(2) / f(1) = 2;<br>  相乘后f(n) / f(1) = 2^(n-1)<br>  由于f(1) = 1<br>  所以f(n) = 2^(n-1)</p></blockquote><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public long monopoly(int step) &#123;</span><br><span class="line">    return (long) Math.pow(2 , step - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;  </span><br><span class="line">    System.out.println(&quot;投骰子的方法有&quot; + monopoly(6) + &quot;种&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n&amp;lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.baidu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.baidu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="http://www.baidu.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="美团" scheme="http://www.baidu.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>美团2016招聘笔试（股票交易日）</title>
    <link href="http://www.baidu.com/2018/02/28/%E7%BE%8E%E5%9B%A22016%E6%8B%9B%E8%81%98%E7%AC%94%E8%AF%95%EF%BC%88%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93%E6%97%A5%EF%BC%89/"/>
    <id>http://www.baidu.com/2018/02/28/美团2016招聘笔试（股票交易日）/</id>
    <published>2018-02-28T03:19:42.542Z</published>
    <updated>2018-02-28T06:48:37.964Z</updated>
    
    <content type="html"><![CDATA[<p>在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用实践复杂度低的方法实现。<br><a id="more"></a></p><blockquote><p>给定价格序列prices及它的长度n，请返回最大收益。保证长度小于等于500。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用实践复杂度低的方法实现。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.baidu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://www.baidu.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="笔试" scheme="http://www.baidu.com/tags/%E7%AC%94%E8%AF%95/"/>
    
      <category term="美团" scheme="http://www.baidu.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>JAVA经典试题四十道</title>
    <link href="http://www.baidu.com/2018/02/26/JAVA%E7%BB%8F%E5%85%B8%E8%AF%95%E9%A2%98%E5%9B%9B%E5%8D%81%E9%81%93/"/>
    <id>http://www.baidu.com/2018/02/26/JAVA经典试题四十道/</id>
    <published>2018-02-26T08:44:56.862Z</published>
    <updated>2018-02-26T09:50:23.900Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"><a href="#1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？" class="headerlink" title="1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"></a>1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</h1><blockquote><p>分析：兔子的规律为数列1,1,2,3,5,8,13,21…. </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 递归方式实现</span><br><span class="line"> */</span><br><span class="line">public int fibonacci(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递推方式实现</span><br><span class="line"> */</span><br><span class="line">public int fibonacciNormal(int n) &#123;</span><br><span class="line">    if (n &lt;= 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    // r1 幼兔 r2 成年兔</span><br><span class="line">    int r1 = 1, r2 = 1, sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; n - 2; i++) &#123;</span><br><span class="line">        sum = r1 + r2;</span><br><span class="line">        r1 = r2;</span><br><span class="line">        r2 = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;  </span><br><span class="line">    System.out.println(&quot;递归方式实现：&quot; + fibonacci(8));  </span><br><span class="line">    System.out.println(&quot;递推方式实现：&quot; + fibonacciNormal(8));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:<br>递归方式实现：21<br>递推方式实现：21</p></blockquote><h1 id="2、判断101-200之间有多少个素数，并输出所有素数。"><a href="#2、判断101-200之间有多少个素数，并输出所有素数。" class="headerlink" title="2、判断101-200之间有多少个素数，并输出所有素数。"></a>2、判断101-200之间有多少个素数，并输出所有素数。</h1><blockquote><p>分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，<br>则表明此数不是素数，反之是素数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 判断是否为素数</span><br><span class="line"> */</span><br><span class="line">public boolean isPrimeNumber(int number) &#123;</span><br><span class="line">    boolean flag = true;</span><br><span class="line">    if (number == 1)</span><br><span class="line">        flag = false;</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int i = 2; i &lt;= Math.sqrt(number); i++) &#123;</span><br><span class="line">            if (number % i == 0 || number == 1) &#123;</span><br><span class="line">                flag = false;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String args[]) &#123;  </span><br><span class="line">    int start = 101;</span><br><span class="line">    int end = 200;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        if (!isPrimeNumber(i)) continue;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.print(i + &quot; &quot;);</span><br><span class="line">        if (count % 10 == 0) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:<br>101 103 107 109 113 127 131 137 139 149<br>151 157 163 167 173 179 181 191 193 197<br>199 </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？&quot;&gt;&lt;a href=&quot;#1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://www.baidu.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>淘宝IP地址库</title>
    <link href="http://www.baidu.com/2018/02/26/%E6%B7%98%E5%AE%9DIP%E5%9C%B0%E5%9D%80%E5%BA%93/"/>
    <id>http://www.baidu.com/2018/02/26/淘宝IP地址库/</id>
    <published>2018-02-26T06:11:35.485Z</published>
    <updated>2018-02-26T06:16:08.786Z</updated>
    
    <content type="html"><![CDATA[<p>根据用户提供的IP地址，快速查询出该IP地址所在的地理信息和地理相关的信息，包括国家、省、市和运营商。<br>用户可以根据自己所在的位置和使用的IP地址更新我们的服务内容。</p><a id="more"></a><h1 id="请求接口（GET）"><a href="#请求接口（GET）" class="headerlink" title="请求接口（GET）"></a>请求接口（GET）</h1><blockquote><p><a href="http://ip.taobao.com/service/getIpInfo2.php?ip=[ip地址字串]" target="_blank" rel="noopener">http://ip.taobao.com/service/getIpInfo2.php?ip=[ip地址字串]</a></p></blockquote><h1 id="响应信息"><a href="#响应信息" class="headerlink" title="响应信息"></a>响应信息</h1><blockquote><p>（json格式的）国家 、省（自治区或直辖市）、市（县）、运营商</p></blockquote><h1 id="返回数据格式"><a href="#返回数据格式" class="headerlink" title="返回数据格式"></a>返回数据格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;:0,</span><br><span class="line">    &quot;data&quot;:&#123;</span><br><span class="line">        &quot;ip&quot;:&quot;210.75.225.254&quot;,</span><br><span class="line">        &quot;country&quot;:&quot;中国&quot;,</span><br><span class="line">        &quot;area&quot;:&quot;华北&quot;,</span><br><span class="line">        &quot;region&quot;:&quot;北京市&quot;,</span><br><span class="line">        &quot;city&quot;:&quot;北京市&quot;,</span><br><span class="line">        &quot;county&quot;:&quot;&quot;,</span><br><span class="line">        &quot;isp&quot;:&quot;电信&quot;,</span><br><span class="line">        &quot;country_id&quot;:&quot;86&quot;,</span><br><span class="line">        &quot;area_id&quot;:&quot;100000&quot;,</span><br><span class="line">        &quot;region_id&quot;:&quot;110000&quot;,</span><br><span class="line">        &quot;city_id&quot;:&quot;110000&quot;,</span><br><span class="line">        &quot;county_id&quot;:&quot;-1&quot;,</span><br><span class="line">        &quot;isp_id&quot;:&quot;100017&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中code的值的含义为，0：成功，1：失败。</p><h1 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h1><blockquote><p>为了保障服务正常运行，每个用户的访问频率需小于10qps。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据用户提供的IP地址，快速查询出该IP地址所在的地理信息和地理相关的信息，包括国家、省、市和运营商。&lt;br&gt;用户可以根据自己所在的位置和使用的IP地址更新我们的服务内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="淘宝" scheme="http://www.baidu.com/tags/%E6%B7%98%E5%AE%9D/"/>
    
      <category term="IP" scheme="http://www.baidu.com/tags/IP/"/>
    
      <category term="接口" scheme="http://www.baidu.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>将一个已存在的目录转换为一个 Git 项目并托管到 GitHub 仓库</title>
    <link href="http://www.baidu.com/2018/02/26/%E5%B0%86%E4%B8%80%E4%B8%AA%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E7%9B%AE%E5%BD%95%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%80%E4%B8%AA%20Git%20%E9%A1%B9%E7%9B%AE%E5%B9%B6%E6%89%98%E7%AE%A1%E5%88%B0%20GitHub%20%E4%BB%93%E5%BA%93/"/>
    <id>http://www.baidu.com/2018/02/26/将一个已存在的目录转换为一个 Git 项目并托管到 GitHub 仓库/</id>
    <published>2018-02-26T03:00:07.994Z</published>
    <updated>2018-02-26T06:05:49.953Z</updated>
    
    <content type="html"><![CDATA[<p>总共以下几个步骤：<br><a id="more"></a></p><blockquote><p>一、 打开命令行终端，进入项目所在的本地目录，将目录初始化为一个 Git 项目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>此时会在目录中创建一个 .git 隐藏文件夹</p><hr><blockquote><p>二、 将所有文件放进新的本地 git 仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>如果你本地已经有 .gitignore 文件，会按照已有规则过滤不需要添加的文件。如果不想要添加所有文件，可以把 . 符号换成具体的文件名</p><hr><blockquote><p>三、 将添加的文件提交到仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;comment&apos;</span><br></pre></td></tr></table></figure><hr><blockquote><p>四、 访问 GitHub</p></blockquote><hr><blockquote><p>五、 创建一个新仓库</p></blockquote><p>为了避免冲突，先不要勾选 README 和 LICENSE 选项</p><hr><blockquote><p>六、 在生成的项目主页上，复制仓库地址</p></blockquote><hr><blockquote><p>七、 回到命令行终端界面，将本地仓库关联到远程仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add remote origin ***.git</span><br></pre></td></tr></table></figure><p>可运行以下命令查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><blockquote><p>八、 提交代码到 GitHub 仓库</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br><span class="line">git branch -set-upstream-to=origin/master</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总共以下几个步骤：&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://www.baidu.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://www.baidu.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>常用的抓包软件</title>
    <link href="http://www.baidu.com/2018/02/23/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6/"/>
    <id>http://www.baidu.com/2018/02/23/常用的抓包软件/</id>
    <published>2018-02-23T08:01:36.033Z</published>
    <updated>2018-02-28T07:46:37.351Z</updated>
    
    <content type="html"><![CDATA[<p>做web开发或者app开发的时候，经常会有抓包的需求。下面总结一下我用过的抓包工具，并分析一下优缺点。<br><a id="more"></a></p><h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p>Wireshark一直是用的最爽的一个工具，在mac和windows下都有一致的界面。但是，Wireshark没有自带proxy，因此需要自己搭建proxy。</p><h1 id="Fiddler"><a href="#Fiddler" class="headerlink" title="Fiddler"></a>Fiddler</h1><p>最好用的抓包工具，支持https、proxy。但是是基于.Net 技术开发的，没办法直接在 Mac/Linux 下使用。</p><h1 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h1><p>自带proxy，支持拦截并修改response，非常好用的一个工具，支持mac。<br>但是只有30天试用，收费的是50刀。网上有免费得注册码。一个缺陷是，很容易丢包。<br>像高德地图的api一个都没抓到，百度地图的却都抓到了。<br>Charles支持Https抓包，但需要在手机上安装一个证书（如果不安转这个证书，在Charles中看到的request和response是乱码）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做web开发或者app开发的时候，经常会有抓包的需求。下面总结一下我用过的抓包工具，并分析一下优缺点。&lt;br&gt;
    
    </summary>
    
      <category term="分享" scheme="http://www.baidu.com/categories/%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="软件" scheme="http://www.baidu.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="抓包" scheme="http://www.baidu.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
</feed>
