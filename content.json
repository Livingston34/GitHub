[{"title":"快速排序法","date":"2018-02-28T08:00:05.269Z","path":"2018/02/28/快速排序法/","text":"快速排序（Quicksort）是对冒泡排序的一种改进。 快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法介绍设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。 代码示例12 试题案例设一组初始记录关键字序列为（49、38、65、97、76、13、27、49），则以第一个关键字49为基准而得到的一趟快速排序结果是（） A. 38，13，27，49，49，65，97，76 B. 13，27，38，49，65，76，97，49 C. 27，38，13，49，76，97，65，49 D. 27，38，13，49，97，76，65，49","tags":[{"name":"算法","slug":"算法","permalink":"http://www.baidu.com/tags/算法/"}]},{"title":"二分查找法","date":"2018-02-28T07:37:40.850Z","path":"2018/02/28/二分查找法/","text":"二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 要求 必须采用顺序存储结构。 必须按关键字大小有序排列。 比较次数 计算公式： 当顺序表有n个关键字时： 查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。 注意：a,b,n均为正整数。 代码示例123456789101112131415161718192021public static int binarySearch(Integer[] srcArray, int des) &#123; // 定义初始最小、最大索引 int low = 0; int high = srcArray.length - 1; // 确保不会出现重复查找，越界 while (low &lt;= high) &#123; // 计算出中间索引值 int middle = (high + low)&gt;&gt;&gt;1 ;//防止溢出 if (des == srcArray[middle]) &#123; return middle; // 判断下限 &#125; else if (des &lt; srcArray[middle]) &#123; high = middle - 1; // 判断上限 &#125; else &#123; low = middle + 1; &#125; &#125; // 若没有，则返回-1 return -1;&#125; 试题案例设有一组关键字序列{5，8，14，20，31，55，78，81，93，97，111}，使用二分（折半）法查找关键字93需要进行多少次比较（A） A. 2 B. 3 C. 4 D. 5 分析 索引为0-10 第一次 left=0,right=10,mid=(left+right)/2=5; 索引为5的为55 第二次 left=mid+1=6 ,right=10;mid=(left+right)/2=8;索引为8的为93.到此比较完毕","tags":[{"name":"算法","slug":"算法","permalink":"http://www.baidu.com/tags/算法/"}]},{"title":"搜狐2016招聘笔试题（扎金花）","date":"2018-02-28T07:19:04.585Z","path":"2018/02/28/搜狐2016招聘笔试题（扎金花）/","text":"两个搜狐的程序员加了一个月班，终于放假了，于是他们决定扎金花渡过愉快的假期 。 游戏规则共52张普通牌，牌面为2,3,4,5,6,7,8,9,10,J,Q,K,A之一，大小递增，各四张； 每人抓三张牌。两人比较手中三张牌大小，大的人获胜。 对于牌型的规则如下: 1.三张牌一样即为豹子 2.三张牌相连为顺子（A23不算顺子） 3.有且仅有两张牌一样为对子 豹子&gt;顺子&gt;对子&gt;普通牌型 在牌型一样时，比较牌型数值大小（如AAA&gt;KKK,QAK&gt;534，QQ2&gt;10104） 在二人均无特殊牌型时，依次比较三张牌中最大的。大的人获胜，如果最大的牌一样，则比较第二大，以此类推（如37K&gt;89Q） 如二人牌面相同，则为平局。 输入描述 输入两个字符串代表两个玩家的牌（如”10KQ” “354”），先输入的作为玩家1，后输入的作为玩家2 输出描述 1 代表 玩家1赢 0 代表 平局 -1 代表 玩家2赢 -2 代表不合法的输入 输入例子 KQ3 3Q9 10QA 6102 5810 7KK 632 74J 10102 K77 JKJ 926 68K 27A 输出例子 1 1 -1 -1 1 1 -1","tags":[{"name":"算法","slug":"算法","permalink":"http://www.baidu.com/tags/算法/"},{"name":"搜狐","slug":"搜狐","permalink":"http://www.baidu.com/tags/搜狐/"},{"name":"笔试","slug":"笔试","permalink":"http://www.baidu.com/tags/笔试/"}]},{"title":"美团2017校招笔试（最大矩形面积）","date":"2018-02-28T06:47:41.006Z","path":"2018/02/28/美团2017校招笔试（最大矩形面积）/","text":"给定一组非负整数组成的数组h，代表一组柱状图的高度，其中每个柱子的宽度都为1。 在这组柱状图中找到能组成的最大矩形的面积（如图所示）。 入参h为一个整型数组，代表每个柱子的高度，返回面积的值。 输入描述 输入包括两行,第一行包含一个整数n(1 ≤ n ≤ 10000) 第二行包括n个整数,表示h数组中的每个值,h_i(1 ≤ h_i ≤ 1,000,000) 输出描述 输出一个整数,表示最大的矩阵面积。 输入例子 6 2 1 5 6 2 3 输出例子 10","tags":[{"name":"算法","slug":"算法","permalink":"http://www.baidu.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://www.baidu.com/tags/笔试/"},{"name":"美团","slug":"美团","permalink":"http://www.baidu.com/tags/美团/"}]},{"title":"美团2017校招笔试（大富翁游戏）","date":"2018-02-28T03:31:19.985Z","path":"2018/02/28/美团2017校招笔试（大富翁游戏）/","text":"大富翁游戏，玩家根据骰子的点数决定走的步数，即骰子点数为1时可以走一步，点数为2时可以走两步，点数为n时可以走n步。求玩家走到第n步（n&lt;=骰子最大点数且是方法的唯一入参）时，总共有多少种投骰子的方法。 输入描述 输入包括一个整数n,(1 ≤ n ≤ 6) 输出描述 输出一个整数,表示投骰子的方法 输入例子 6 输出例子 32 分析 f(n)=f(n-1)+f(n-2)+…+1; 在玩家走到第n步的情况， 可能是先走了n-1步，剩下1步到达； 也可能是先走n-2步，剩下再走2步到达； …； 也可能是先走了1步，剩下再走n-1步。 即 f(n) 是f(n-1)…f(1)的情况相加，再加上最后一步。 则f(n) = f(n-1) + f(n-2) + … + f(1) + 1 计算通项式 f(n) = f(n-1) + f(n-2) + … + f(1) + 1 ① f(n-1) = f(n-2) + f(n-3) + … + f(1) + 1 ② 那么② - ①得出 f(n) = 2 * f(n-1) 利用数列的递推公式 f(n) / f(n-1) = 2; f(n-1) / f(n-2) = 2; … f(2) / f(1) = 2; 相乘后f(n) / f(1) = 2^(n-1) 由于f(1) = 1 所以f(n) = 2^(n-1) 实现1234567public long monopoly(int step) &#123; return (long) Math.pow(2 , step - 1);&#125;public static void main(String args[]) &#123; System.out.println(&quot;投骰子的方法有&quot; + monopoly(6) + &quot;种&quot;); &#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://www.baidu.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://www.baidu.com/tags/笔试/"},{"name":"美团","slug":"美团","permalink":"http://www.baidu.com/tags/美团/"}]},{"title":"美团2016招聘笔试（股票交易日）","date":"2018-02-28T03:19:42.542Z","path":"2018/02/28/美团2016招聘笔试（股票交易日）/","text":"在股市的交易日中，假设最多可进行两次买卖(即买和卖的次数均小于等于2)，规则是必须一笔成交后进行另一笔(即买-卖-买-卖的顺序进行)。给出一天中的股票变化序列，请写一个程序计算一天可以获得的最大收益。请采用实践复杂度低的方法实现。 给定价格序列prices及它的长度n，请返回最大收益。保证长度小于等于500。","tags":[{"name":"算法","slug":"算法","permalink":"http://www.baidu.com/tags/算法/"},{"name":"笔试","slug":"笔试","permalink":"http://www.baidu.com/tags/笔试/"},{"name":"美团","slug":"美团","permalink":"http://www.baidu.com/tags/美团/"}]},{"title":"JAVA经典试题四十道","date":"2018-02-26T08:44:56.862Z","path":"2018/02/26/JAVA经典试题四十道/","text":"1、有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？ 分析：兔子的规律为数列1,1,2,3,5,8,13,21…. 12345678910111213141516171819202122232425262728293031/** * 递归方式实现 */public int fibonacci(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; return fibonacci(n - 1) + fibonacci(n - 2);&#125;/** * 递推方式实现 */public int fibonacciNormal(int n) &#123; if (n &lt;= 2) &#123; return 1; &#125; // r1 幼兔 r2 成年兔 int r1 = 1, r2 = 1, sum = 0; for (int i = 0; i &lt; n - 2; i++) &#123; sum = r1 + r2; r1 = r2; r2 = sum; &#125; return sum;&#125;public static void main(String args[]) &#123; System.out.println(&quot;递归方式实现：&quot; + fibonacci(8)); System.out.println(&quot;递推方式实现：&quot; + fibonacciNormal(8)); &#125; 输出结果:递归方式实现：21递推方式实现：21 2、判断101-200之间有多少个素数，并输出所有素数。 分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。 12345678910111213141516171819202122232425262728293031/** * 判断是否为素数 */public boolean isPrimeNumber(int number) &#123; boolean flag = true; if (number == 1) flag = false; else &#123; for (int i = 2; i &lt;= Math.sqrt(number); i++) &#123; if (number % i == 0 || number == 1) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125;public static void main(String args[]) &#123; int start = 101; int end = 200; int count = 0; for (int i = start; i &lt;= end; i++) &#123; if (!isPrimeNumber(i)) continue; count++; System.out.print(i + &quot; &quot;); if (count % 10 == 0) &#123; System.out.println(); &#125; &#125; &#125; 输出结果:101 103 107 109 113 127 131 137 139 149151 157 163 167 173 179 181 191 193 197199","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.baidu.com/tags/JAVA/"}]},{"title":"淘宝IP地址库","date":"2018-02-26T06:11:35.485Z","path":"2018/02/26/淘宝IP地址库/","text":"根据用户提供的IP地址，快速查询出该IP地址所在的地理信息和地理相关的信息，包括国家、省、市和运营商。用户可以根据自己所在的位置和使用的IP地址更新我们的服务内容。 请求接口（GET） http://ip.taobao.com/service/getIpInfo2.php?ip=[ip地址字串] 响应信息 （json格式的）国家 、省（自治区或直辖市）、市（县）、运营商 返回数据格式123456789101112131415161718&#123; &quot;code&quot;:0, &quot;data&quot;:&#123; &quot;ip&quot;:&quot;210.75.225.254&quot;, &quot;country&quot;:&quot;中国&quot;, &quot;area&quot;:&quot;华北&quot;, &quot;region&quot;:&quot;北京市&quot;, &quot;city&quot;:&quot;北京市&quot;, &quot;county&quot;:&quot;&quot;, &quot;isp&quot;:&quot;电信&quot;, &quot;country_id&quot;:&quot;86&quot;, &quot;area_id&quot;:&quot;100000&quot;, &quot;region_id&quot;:&quot;110000&quot;, &quot;city_id&quot;:&quot;110000&quot;, &quot;county_id&quot;:&quot;-1&quot;, &quot;isp_id&quot;:&quot;100017&quot; &#125;&#125; 其中code的值的含义为，0：成功，1：失败。 访问限制 为了保障服务正常运行，每个用户的访问频率需小于10qps。","tags":[{"name":"淘宝","slug":"淘宝","permalink":"http://www.baidu.com/tags/淘宝/"},{"name":"IP","slug":"IP","permalink":"http://www.baidu.com/tags/IP/"},{"name":"接口","slug":"接口","permalink":"http://www.baidu.com/tags/接口/"}]},{"title":"将一个已存在的目录转换为一个 Git 项目并托管到 GitHub 仓库","date":"2018-02-26T03:00:07.994Z","path":"2018/02/26/将一个已存在的目录转换为一个 Git 项目并托管到 GitHub 仓库/","text":"总共以下几个步骤： 一、 打开命令行终端，进入项目所在的本地目录，将目录初始化为一个 Git 项目 1git init 此时会在目录中创建一个 .git 隐藏文件夹 二、 将所有文件放进新的本地 git 仓库 1git add . 如果你本地已经有 .gitignore 文件，会按照已有规则过滤不需要添加的文件。如果不想要添加所有文件，可以把 . 符号换成具体的文件名 三、 将添加的文件提交到仓库 1git commit -m &apos;comment&apos; 四、 访问 GitHub 五、 创建一个新仓库 为了避免冲突，先不要勾选 README 和 LICENSE 选项 六、 在生成的项目主页上，复制仓库地址 七、 回到命令行终端界面，将本地仓库关联到远程仓库 1git add remote origin ***.git 可运行以下命令查看结果： 1git remote -v 八、 提交代码到 GitHub 仓库 123git pullgit branch -set-upstream-to=origin/mastergit push origin master","tags":[{"name":"Git","slug":"Git","permalink":"http://www.baidu.com/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://www.baidu.com/tags/GitHub/"}]},{"title":"常用的抓包软件","date":"2018-02-23T08:01:36.033Z","path":"2018/02/23/常用的抓包软件/","text":"做web开发或者app开发的时候，经常会有抓包的需求。下面总结一下我用过的抓包工具，并分析一下优缺点。 WireSharkWireshark一直是用的最爽的一个工具，在mac和windows下都有一致的界面。但是，Wireshark没有自带proxy，因此需要自己搭建proxy。 Fiddler最好用的抓包工具，支持https、proxy。但是是基于.Net 技术开发的，没办法直接在 Mac/Linux 下使用。 Charles自带proxy，支持拦截并修改response，非常好用的一个工具，支持mac。但是只有30天试用，收费的是50刀。网上有免费得注册码。一个缺陷是，很容易丢包。像高德地图的api一个都没抓到，百度地图的却都抓到了。Charles支持Https抓包，但需要在手机上安装一个证书（如果不安转这个证书，在Charles中看到的request和response是乱码）","tags":[{"name":"软件","slug":"软件","permalink":"http://www.baidu.com/tags/软件/"},{"name":"抓包","slug":"抓包","permalink":"http://www.baidu.com/tags/抓包/"}]}]